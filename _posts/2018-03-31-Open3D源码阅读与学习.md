---
layout: post
title: Open3D源码阅读与学习
categories: [Open3D]
tags: [c++, 开发，Open3D]
redirect_from:
  - /2018/03/31
---

* Kramdown table of contents
{:toc .toc}

# [Open3D](http://http://open3d.org/) 简介
> Open3D是由IntelVCL小组开发的一款轻量级的三维数据处理库。其采用C++11开发，同时与Python完美适配。作者本着usefulness and ease of use 的原则，对数据结构，和算法进行了精细的选择。没有依赖大型库如boost，PCL等，是一个小巧独立的三维点云库。笔者最喜欢的是其visualizer的设计，相比而言其可视化模块易用性比PCL的要高，同时还支持动画。

# Open3D的安装
Open3D的所有[源码](https://github.com/IntelVCL/Open3D)在github上，使用者只需要按照其提供的安装教程，进行编译即可。这里需要注意的是，Ubuntu系统上对Python的选择默认的是Python3，那么还是使用Python2.7的用户需要手动将这两个变量修改一下，再进行编译即可。如果还有疑惑可以参阅[Document](http://www.open3d.org/docs)。
~~~
PYTHON_EXECUTABLE                /usr/bin/python
PYTHON_LIBRARY                   /usr/lib/x86_64-linux-gnu/libpython2.7.so 
~~~

# Open3D的Python使用
由于整个项目还在持续的开发，所以作者希望大家使用其Python借口，而不是使用CPP接口。
编译完成之后，我们可以在build文件夹下面，找到lib文件夹，在下面的Tutorial文件夹有关于Python接口的全部教程。结合其官方的英文文档可以较轻松的学习整个项目的功能。笔者就不一一赘述了。下面主要介绍CPP接口的使用。

# C++接口的使用

### 准备工作
不幸的是我们并没有一个CPP接口的官方教程，然后整个项目也没有提供make install的功能（不久以后，应该会有）。我们就需要没有条件创造条件也要上了。想要使用其CPP接口，首先需要头文件，然后我们需要库文件，.a或者.so。

#### 头文件
我们首先提取头文件。万幸的是，Open3D的cmake文件写的很好，很有条理，我们可以发现在Core，IO，Visualization三个文件夹下面有分别关于这个模块的CMakeLists.txt文件，我们修改这些CMakeLists.txt文件。
~~~
Core模块CMakeLists.txt末尾添加
install(FILES ${headers} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core)
install(FILES ${CORE_UTILITY_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core/Utility)
install(FILES ${CORE_GEOMETRY_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core/Geometry)
install(FILES ${CORE_CAMERA_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core/Camera)
install(FILES ${CORE_REGISTRATION_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core/Registration)
install(FILES ${CORE_ODOMETRY_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core/Odometry)
install(FILES ${CORE_INTEGRATION_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Core/Integration)
~~~

~~~
IO模块CMakeLists.txt末尾添加
install(FILES ${headers} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/IO)
install(FILES ${IO_CLASSIO_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/IO/ClassIO)
install(FILES ${IO_FILEFORMAT_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/IO/FileFormat)
~~~
~~~
Visualization模块CMakeLists.txt末尾添加
install(FILES ${headers} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Visualization)
install(FILES ${VISUALIZATION_UTILITY_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Visualization/Utility)
install(FILES ${VISUALIZATION_SHADER_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Visualization/Shader)
install(FILES ${VISUALIZATION_VISUALIZER_HEADER_FILES} DESTINATION ${CMAKE_INSTALL_PREFIX}/include/Visualization/Visualizer)
~~~
这样通过make install可以把所有的头文件放好。
#### 库文件
然后关于库文件，这里我就偷了个懒，直接复制的，当然也可以通过修改CMakeLists.txt文件来实现。

#### 构建.cmake文件
我们知道当使用一个用cmake来管理的CPP库的时候，可以使用find_package()来寻找这个库的头文件，库文件，然后生成对应的变量，用于接下来的项目编译。同样的我们希望使用find_package()来管理Open3D，这样我们就需要写一个.cmake文件。
~~~
FindOpen3d.cmake
include_directories(/usr/include/eigen3/)
include_directories(/usr/include/GL)

set(OPEN3D_INCLUDE_DIRS /home/sun/src/Open3D/install/include)
link_directories(/home/sun/src/Open3D/install/lib)


find_package(OpenMP)
if (OPENMP_FOUND)
    set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}")
endif()

set(OPEN3D_LIBRARIES
        Visualization
        IO
        Core
        IO
        pthread
        tinyfiledialogs
        jpeg
        png
        jsoncpp
        zlib
        /usr/lib/x86_64-linux-gnu/libglfw.so
        /usr/lib/x86_64-linux-gnu/libGLEW.so
        /usr/lib/x86_64-linux-gnu/libdl.so
        /usr/lib/x86_64-linux-gnu/librt.so
        /usr/lib/x86_64-linux-gnu/libm.so
        /usr/lib/x86_64-linux-gnu/libX11.so
        /usr/lib/x86_64-linux-gnu/libXrandr.so
        /usr/lib/x86_64-linux-gnu/libXinerama.so
        /usr/lib/x86_64-linux-gnu/libXi.so
        /usr/lib/x86_64-linux-gnu/libXxf86vm.so
        /usr/lib/x86_64-linux-gnu/libXcursor.so
        /usr/lib/x86_64-linux-gnu/libGL.so
        )
~~~
然后我们在写自己项目的CMakeLists.txt的时候将FindOpen3d.cmake所在的目录添加到CMAKE_MODULE_PATH环境变量中去。就可以使用find_package来配置Open3d库了。

### Open3D之PointCloud
> Open3D的CPP接口[文档](http://open3d.org/cppapi/)

点云是三维数据处理中的基本的数据结构。在经典的点云库（PCL）中，点云是一种比较复杂的数据结构，而在Open3D中点云较为简单。

![点云继承关系](/assets/images/pics/pointcloud.png "点云继承关系")

由图中可以看到，点云继承自Geometry3D而Geometry3D继承自Geometry。Geometry是一个纯粹的抽象类，也就是所有的几何数据类型都是以其为模板，它有一个枚举，包含了Unspecified，PointCloud，Lineset，TriangleMesh，Image。而Geometry3D则会有一些bound，和Transform的属性，更为具体。
PointCloud由数据点，法线，和颜色构成。结构较为简单。

```
// ----------------------------------------------------------------------------
// -                        Open3D: www.open3d.org                            -
// ----------------------------------------------------------------------------
// The MIT License (MIT)
//
// Copyright (c) 2018 www.open3d.org
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include <Eigen/Dense>

#include <Core/Core.h>
#include <IO/IO.h>
#include <Visualization/Visualization.h>

void PrintPointCloud(const three::PointCloud &pointcloud)
{
    using namespace three;

    bool pointcloud_has_normal = pointcloud.HasNormals();
    PrintInfo("Pointcloud has %d points.\n",
              (int)pointcloud.points_.size());

    Eigen::Vector3d min_bound = pointcloud.GetMinBound();
    Eigen::Vector3d max_bound = pointcloud.GetMaxBound();
    PrintInfo("Bounding box is: (%.4f, %.4f, %.4f) - (%.4f, %.4f, %.4f)\n",
              min_bound(0), min_bound(1), min_bound(2),
              max_bound(0), max_bound(1), max_bound(2));

    for (size_t i = 0; i < pointcloud.points_.size(); i++) {
        if (pointcloud_has_normal) {
            const Eigen::Vector3d &point = pointcloud.points_[i];
            const Eigen::Vector3d &normal = pointcloud.normals_[i];
            PrintDebug("%.6f %.6f %.6f %.6f %.6f %.6f\n",
                       point(0), point(1), point(2),
                       normal(0), normal(1), normal(2));
        } else {
            const Eigen::Vector3d &point = pointcloud.points_[i];
            PrintDebug("%.6f %.6f %.6f\n", point(0), point(1), point(2));
        }
    }
    PrintDebug("End of the list.\n\n");
}

int main(int argc, char *argv[])
{

    using namespace three;

    SetVerbosityLevel(VerbosityLevel::VerboseAlways);

    if(argc < 2)
    {
        PrintError("请给定点云文件！");
    }

    auto pcd = CreatePointCloudFromFile(argv[1]); //! 工厂函数
    {
        ScopeTimer timer("FPFH estimation with Radius 0.25"); //! 块计时器，在析构的时候打印耗时
        //for (int i = 0; i < 20; i++) {
        ComputeFPFHFeature(*pcd,
                           three::KDTreeSearchParamRadius(0.25));
        //}
    }

    {
        ScopeTimer timer("Normal estimation with KNN20");
        for (int i = 0; i < 20; i++) {
            EstimateNormals(*pcd,
                            three::KDTreeSearchParamKNN(20)); //! 已20个点来估算一个点的normal
        }
    }
    std::cout << pcd->normals_[0] << std::endl;
    std::cout << pcd->normals_[10] << std::endl;

    {
        ScopeTimer timer("Normal estimation with Radius 0.01666");
        for (int i = 0; i < 20; i++) {
            EstimateNormals(*pcd,
                            three::KDTreeSearchParamRadius(0.01666)); //! 半径来估算
        }
    }
    std::cout << pcd->normals_[0] << std::endl;
    std::cout << pcd->normals_[10] << std::endl;

    {
        ScopeTimer timer("Normal estimation with Hybrid 0.01666, 60");
        for (int i = 0; i < 20; i++) {
            EstimateNormals(*pcd,
                            three::KDTreeSearchParamHybrid(0.01666, 60)); //! 混合估算，第一个参数为半径，后面一个参数为数量
        }
    }
    std::cout << pcd->normals_[0] << std::endl;
    std::cout << pcd->normals_[10] << std::endl;

    auto downpcd = VoxelDownSample(*pcd, 0.05); //! 体素降采样,0.05代表最小的一个box长度为0.05

    // 1. test basic pointcloud functions.

    PointCloud pointcloud;
    PrintPointCloud(pointcloud);
    //! https://blog.csdn.net/xiaolewennofollow/article/details/52559364
    //! https://blog.csdn.net/yockie/article/details/52674366
    //! https://blog.csdn.net/kaitiren/article/details/22302579
    //! emplace_back只调用构造函数，不调用拷贝构造，和转移构造函数，速度很快
    pointcloud.points_.emplace_back(0.0, 0.0, 0.0);
    pointcloud.points_.emplace_back(1.0, 0.0, 0.0);
    pointcloud.points_.emplace_back(0.0, 1.0, 0.0);
    pointcloud.points_.emplace_back(0.0, 0.0, 1.0);
    PrintPointCloud(pointcloud);

    // 2. test pointcloud IO.

    const std::string filename_xyz("test.xyz");
    const std::string filename_ply("test.ply");

    if (ReadPointCloud(argv[1], pointcloud)) {
        PrintWarning("Successfully read %s\n", argv[1]);

        /*
        PointCloud pointcloud_copy;
        pointcloud_copy.CloneFrom(pointcloud);

        if (WritePointCloud(filename_xyz, pointcloud)) {
            PrintWarning("Successfully wrote %s\n\n", filename_xyz.c_str());
        } else {
            PrintError("Failed to write %s\n\n", filename_xyz.c_str());
        }

        if (WritePointCloud(filename_ply, pointcloud_copy)) {
            PrintWarning("Successfully wrote %s\n\n", filename_ply.c_str());
        } else {
            PrintError("Failed to write %s\n\n", filename_ply.c_str());
        }
         */
    } else {
        PrintError("Failed to read %s\n\n", argv[1]);
    }

    // 3. test pointcloud visualization

    Visualizer visualizer;
    std::shared_ptr<PointCloud> pointcloud_ptr(new PointCloud);
    *pointcloud_ptr = pointcloud;
    pointcloud_ptr->NormalizeNormals();
    BoundingBox bounding_box;
    bounding_box.FitInGeometry(*pointcloud_ptr);

    std::shared_ptr<PointCloud> pointcloud_transformed_ptr(new PointCloud);
    *pointcloud_transformed_ptr = *pointcloud_ptr;
    Eigen::Matrix4d trans_to_origin = Eigen::Matrix4d::Identity();
    trans_to_origin.block<3, 1>(0, 3) = bounding_box.GetCenter() * -1.0;
    Eigen::Matrix4d transformation = Eigen::Matrix4d::Identity();
    transformation.block<3, 3>(0, 0) = static_cast<Eigen::Matrix3d>(
            Eigen::AngleAxisd(M_PI / 4.0, Eigen::Vector3d::UnitX()));
    pointcloud_transformed_ptr->Transform(
            trans_to_origin.inverse() * transformation * trans_to_origin);
            //! 先把所有的点云归到原点，然后，绕着x轴旋转45度，然后再平移回去，总的来说就是绕着点云的中心点绕着x轴旋转45度

    visualizer.CreateWindow("Open3D", 1600, 900);
    visualizer.AddGeometry(pointcloud_ptr);
    visualizer.AddGeometry(pointcloud_transformed_ptr);
    visualizer.Run();
    visualizer.DestroyWindow();

    auto coord = CreateMeshCoordinateFrame(0.2);

    // 4. test operations
    *pointcloud_transformed_ptr += *pointcloud_ptr;
    DrawGeometries({pointcloud_transformed_ptr,coord}, "Combined Pointcloud");

    // 5. test downsample
    auto downsampled = VoxelDownSample(*pointcloud_ptr, 0.05);
    DrawGeometries({downsampled,coord}, "Down Sampled Pointcloud");

    // 6. test normal estimation
    //! https://segmentfault.com/a/1190000006212012
    //! [&] 表达式的意思是所有的局部变量将按照引用的方式进行传递
    DrawGeometriesWithKeyCallbacks({pointcloud_ptr},
                                   {{GLFW_KEY_SPACE, [&](Visualizer *vis) {
                                       //EstimateNormals(*pointcloud_ptr,
                                       //		three::KDTreeSearchParamKNN(20));
                                       EstimateNormals(*pointcloud_ptr,
                                                       three::KDTreeSearchParamRadius(0.05));
                                       PrintInfo("Done.\n");
                                       return true;
                                   }}},
                                   "Press Space to Estimate Normal", 1600, 900);

    // n. test end

    PrintAlways("End of the test.\n");
}
```





































